profiles[[c]][[1]]
most_prob_kmer(seq, profiles[[c]][[1]], k)
sapply(1:length(profiles), function(p){
c<<- c + 1
most_probable <- most_prob_kmer(seq, profiles[[c]][[1]], k)
})
c<- 0
sapply(1:length(profiles), function(p){
c<<- c + 1
most_probable <- most_prob_kmer(seq, profiles[[c]][[1]], k)
})
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
})
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
profiles
most_prob_kmer(seq, profiles[[p]][[1]], k)
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
})
most_prob_kmer(seq, profiles[[p]][[1]], k)
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
names(most_probable)
})
})
most_probable
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
list(names(most_probable), most_probable)
})
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
c(names(most_probable), most_probable)
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
names(most_probable)
})
probs <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
most_probable
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
names(most_probable)
})
probs <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
most_probable
})
})
probs
prod(1,2)
prod(3,2)
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
list(names(most_probable), prod(most_probable))
sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
list(names(most_probable), prod(most_probable))
})
most_probable
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
list(names(most_probable), most_probable)
})
names
rowbind(names[1,],prod(names[2,])
)
rbind(names[1,],prod(names[2,]))
names[1,]
names[2,]
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
names
prod(names)
cbind(names(names),prod(names))
rbind(names(names),prod(names))
names
names[1]
s1_kmers
length(s1_kmers)
size <- length(s1_kmers)
prob <- length(s1_kmers)
names[prob] <- prod(names)
names
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
names
names(names)
prod(names)
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
c(names(names),prod(names))
})
names
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
names(names)
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(list(names(names),names))
})
lapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(list(names(names),names))
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return((names(names),names))
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(names(names),names)
})
sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
table
table[size:(size+size),]
table[size+1:(size+size+1),]
table[(size+1):(size+size+1),]
table[(size+1):(size+size),]
probs_only <- table[(size+1):(size+size),]
apply(prob_only, 1, prod)
apply(probs_only, 1, prod)
apply(as.numeric(probs_only), 1, prod)
as.numeric(probs_only)
as.numeric(probs_only[,])
as.numeric(probs_only[1,])
apply(probs_only, 1, function(w){prod(as.numeric(w)))
apply(probs_only, 1, function(w){prod(as.numeric(w))})
the_kmers <- table[1:size,]
the_kmers
cbind(the_kmers,apply(probs_only, 1, function(w){prod(as.numeric(w))}))
cbind(the_kmers, as=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
t_prob <- cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
head(t_prob)
most_probable_k
most_probable_k
t_prob
sort(t_prob$t_prob)
sort(t_prob[,t+1])
order(t_prob[,t+1])
order(as.numeric(t_prob[,t+1]))
order(as.numeric(t_prob[,t+1]), decreazing=T)
order(as.numeric(t_prob[,t+1]), decreazing=F)
order(as.numeric(t_prob[,t+1]), decreasing=T)
t_prob[order(as.numeric(t_prob[,t+1]), decreasing=T),]
library("kebabs")
source("most_prob_kmer.R")
greedy_motif_search <- function(sequences, k, t){
if(length(sequences)==1){
sequences <-gsub("\\s+", " ", sequences)
sequences <- strsplit(sequences, " ")[[1]]
}
kernel <- spectrumKernel(k=k, normalized=FALSE)
s1_kmers <- drop(getExRep(DNAString(sequences[1]), kernel))
s1_kmers <- names(s1_kmers)
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k)
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
the_kmers <- table[1:size,]
probs_only <- table[(size+1):(size+size),]
t_prob <- cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
return(t_prob[order(as.numeric(t_prob[,t+1]), decreasing=T),])
}
library("kebabs")
source("most_prob_kmer.R")
greedy_motif_search <- function(sequences, k, t){
if(length(sequences)==1){
sequences <-gsub("\\s+", " ", sequences)
sequences <- strsplit(sequences, " ")[[1]]
}
kernel <- spectrumKernel(k=k, normalized=FALSE)
s1_kmers <- drop(getExRep(DNAString(sequences[1]), kernel))
s1_kmers <- names(s1_kmers)
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k)
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
the_kmers <- table[1:size,]
probs_only <- table[(size+1):(size+size),]
t_prob <- cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
return(t_prob[order(as.numeric(t_prob[,t+1]), decreasing=T),])
}
sequences <- "GGCGTTCAGGCA     AAGAATCAGTCA     CAAGGAGTTCGC     CACGTCAATCAC     CAATAATATTCG"
k <- 3
t <- 5
greedy_motif_search(sequences,k,t)
if(length(sequences)==1){
sequences <-gsub("\\s+", " ", sequences)
sequences <- strsplit(sequences, " ")[[1]]
}
kernel <- spectrumKernel(k=k, normalized=FALSE)
s1_kmers <- drop(getExRep(DNAString(sequences[1]), kernel))
s1_kmers <- names(s1_kmers)
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k)
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
table
size
most_probable_k
length(most_probable_k[,1])
library("kebabs")
source("most_prob_kmer.R")
greedy_motif_search <- function(sequences, k, t){
if(length(sequences)==1){
sequences <-gsub("\\s+", " ", sequences)
sequences <- strsplit(sequences, " ")[[1]]
}
kernel <- spectrumKernel(k=k, normalized=FALSE)
s1_kmers <- drop(getExRep(DNAString(sequences[1]), kernel))
s1_kmers <- names(s1_kmers)
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k[,1])
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
the_kmers <- table[1:size,]
probs_only <- table[(size+1):(size+size),]
t_prob <- cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
return(t_prob[order(as.numeric(t_prob[,t+1]), decreasing=T),])
}
sequences <- "GGCGTTCAGGCA     AAGAATCAGTCA     CAAGGAGTTCGC     CACGTCAATCAC     CAATAATATTCG"
k <- 3
t <- 5
greedy_motif_search(sequences,k,t)
data <- readLines("data/greedy_data.txt")
data
sequences <- data[3:27]
sequences
strsplit(data[2], " ")[[1])[1]
strsplit(data[2], " ")[[1][1]
strsplit(data[2], " ")[[1]
strsplit(data[2], " ")[[1]]
strsplit(data[2], " ")[[1]][1]
data <- readLines("data/greedy_data.txt")
t <- as.numeric(strsplit(data[2], " ")[[1]][2])
k <- as.numeric(strsplit(data[2], " ")[[1]][1])
sequences <- data[3:27]
greedy_motif_search(sequences,k,t)
if(length(sequences)==1){
sequences <-gsub("\\s+", " ", sequences)
sequences <- strsplit(sequences, " ")[[1]]
}
kernel <- spectrumKernel(k=k, normalized=FALSE)
s1_kmers <- drop(getExRep(DNAString(sequences[1]), kernel))
s1_kmers <- names(s1_kmers)
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k[,1])
s1_kmers
most_probable_k
most_probable_k <- sapply(s1_kmers, function(x){
profile <- (as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local"))))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
s1_kmers
x <- s1_kmers[1]
profile <- as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local")))
profile
stringDist(unique(profile), method = "hamming")
hamming
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
count <- 0
count <- 0
most_probable_k <- sapply(s1_kmers, function(x){
count <<- count +1
profile <- as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local")))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
x <- s1_kmers[count]
as.character(subject(pairwiseAlignment(rep(x,t),sequences,type="global-local")))
pairwiseAlignment(rep(x,t),sequences,type="global-local")
pairwiseAlignment(rep(x,t),sequences,type="global-local")[1]
pairwiseAlignment(rep(x,t),sequences,type="global-local")[2]
pairwiseAlignment(rep(x,t),sequences,type="global-local")[13]
pairwiseAlignment(rep(x,t),sequences,type="global")[13]
pairwiseAlignment(rep(x,t),sequences)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local")[13]
pairwiseAlignment(rep(x,t),sequences,type="local-global")[13]
?pairwiseAlignment
pairwiseAlignment(rep(x,t),sequences,type="global-local")[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=-10)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=0)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=1)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=-1)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=-Inf)[13]
pairwiseAlignment(rep(x,t),sequences,type="global-local", gapOpening=-Inf,gapExtension=0)[13]
most_probable_k <- sapply(s1_kmers, function(x){
count <<- count +1
profile <- as.character(subject(pairwiseAlignment(rep(x,t), sequences,type="global-local",
gapOpening=-Inf,gapExtension=0)[13]))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k
profile <- as.character(subject(pairwiseAlignment(rep(x,t), sequences,type="global-local",
gapOpening=-Inf,gapExtension=0)[13]))
hamming <- stringDist(unique(profile), method = "hamming")
hamming
stringDist(unique(profile), method = "hamming")
stringDist(unique(profile))
?stringDist
profile
most_probable_k <- sapply(s1_kmers, function(x){
profile <- as.character(subject(pairwiseAlignment(rep(x,t), sequences,type="global-local",
gapOpening=-Inf,gapExtension=0)))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k <- head(most_probable_k)
size <- length(most_probable_k[,1])
most_probable_k
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
the_kmers <- table[1:size,]
probs_only <- table[(size+1):(size+size),]
t_prob <- cbind(the_kmers, t_prob=apply(probs_only, 1, function(w){prod(as.numeric(w))}))
t_prob[order(as.numeric(t_prob[,t+1]), decreasing=T),]
most_probable_k <- sapply(s1_kmers, function(x){
profile <- as.character(subject(pairwiseAlignment(rep(x,t), sequences,type="global-local",
gapOpening=-Inf,gapExtension=0)))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
size <- length(most_probable_k[,1])
table <- sapply(sequences, function(seq){
profiles <- apply(most_probable_k, 1, function(z){
matrix <- consensusMatrix(DNAStringSet(z[1:t]), as.prob=T, baseOnly=TRUE)
list(matrix[1:4,])
})
names <- sapply(1:length(profiles), function(p){
most_probable <- most_prob_kmer(seq, profiles[[p]][[1]], k)
})
return(c(names(names),names))
})
most_probable_k
most_probable_k[1]
most_probable_k[1,]
most_probable_k <- sapply(s1_kmers, function(x){
profile <- as.character(subject(pairwiseAlignment(rep(x,t), sequences,type="global-local",
gapOpening=-Inf)))
hamming <- stringDist(unique(profile), method = "hamming")
c(profile, sum(hamming))
})
most_probable_k[1,]
most_probable_k <- t(most_probable_k[,order(as.numeric(most_probable_k[t+1,]))])
most_probable_k[1,]
