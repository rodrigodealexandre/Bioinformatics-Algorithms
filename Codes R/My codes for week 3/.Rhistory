}
##################################################################################
###### does two string approximately match (differ by at most d positions) #######
##################################################################################
match <- function(string1, string2, d=0){
charStr1 <- strsplit(x=string1, split="")[[1]]
charStr2 <- strsplit(x=string2, split="")[[1]]
diff <- sum( charStr1 != charStr2)
return(diff <= d)
}
#####################################################
###### Given a dna (string), a segment (pattern) ####
###### Find all the positions in the dna   ##########
###### where the segment matches the dna   ##########
###### (at most d mutations is acceptable) ##########
#####################################################
findMatches <- function(string, pattern, d=0, indexBase=1){
lenPattern <- str_length(pattern)
lenStr <- str_length(string)
if(lenPattern > lenStr)
return(c())
charPattern <- strsplit(x=pattern, split="")[[1]]
matches <- sapply(1:(lenStr-lenPattern+1), function(start){
end <- start + lenPattern - 1
curStr <- substr(string, start, end)
charCurStr <- strsplit(x=curStr, split="")[[1]]
diff <- sum( charPattern != charCurStr)
return(diff <= d)
})
matchIndexes <- which(matches==T)
if(indexBase != 1)
matchIndexes <- matchIndexes - 1 + indexBase
return(matchIndexes)
}
#####################################################
##### convert a string to C-like char vector ########
#####################################################
stringToCharVec <- function(string){
if(is.null(string) || is.na(string))
return(c())
charVec <- strsplit(string, split="")[[1]]
return(charVec)
}
#####################################################
#### calculate hamming distance between 2 strings ###
#####################################################
hammingDistance <- function(string1, string2){
ch1 <- stringToCharVec(string1)
ch2 <- stringToCharVec(string2)
return(sum(ch1!=ch2))
}
#########################################
#### Given a pattern and a dna   ########
#### Find the minimun distance    #######
#### between the pattern and dna    #####
#### when pattern slides over the dna ###
#########################################
distanceBetweenPatternAndDna <- function(pattern, dna){
k <- str_length(pattern)
kmers <- getKmers(dna, k=k, unique=T)
distances <- sapply(kmers, hammingDistance, pattern)
return(min(distances))
}
################################################
#### Given a pattern and a dna collection ######
#### Find the distance between them   ##########
################################################
distanceBetweenPatternAndDnaCollection <- function(pattern, dnaCollection){
distances <- sapply(dnaCollection, function(dna){
return(distanceBetweenPatternAndDna(pattern=pattern, dna=dna))
})
return(sum(distances))
}
#######################################
##### Get all possible DNA ############
#######################################
getAllPossibleDna <- function(len){
allDnaVector <- permutations(4,len,c("A","T","G","C"), repeats.allowed=T)
allDna <- apply(allDnaVector, 1, paste0, collapse="")
return(allDna)
}
###############################################
#### Given a profile matrix           #########
#### Find the probability of a dna segment ####
###############################################
probabilityOfDna <- function(dna, profileMatrix){
if(is.null(dna) || is.na(dna))
return(0)
dnaVec <- stringToCharVec(dna)
prob <- sapply(1:length(dnaVec), function(pos){
return(profileMatrix[pos, dnaVec[pos]])
})
probability <- prod(prob)
return(probability)
}
# Given a profile matrix Profile, we can evaluate the probability of every k-mer in a string Text and find a Profile-most probable k-mer in Text, i.e., a k-mer that was most likely to have been generated by Profile. For example, ACGGGGATTACC is the Profile-most probable 12-mer in GGTACGGGGATTACCT. Indeed, every other 12-mer in this string has probability 0.
#
# Profile-most Probable k-mer Problem: Find a Profile-most probable k-mer in a string.
# Input: A string Text, an integer k, and a k Ã— 4 matrix Profile.
# Output: A Profile-most probable k-mer in Text.
profileMostProbableKmer <- function(dna, k, profile){
kmers <- getKmers(text=dna, k=k, unique=T)
probabilities <- sapply(kmers, probabilityOfDna, profile)
maxProbableKmerIndex <- which(probabilities==max(probabilities))
mostProbableKmer <- kmers[maxProbableKmerIndex]
return(mostProbableKmer)
}
###############################################
#### Given a set of motifs         ############
#### Calculate the profile matrix  ############
###############################################
motifsToProfile_v0.1 <- function(motifs, pseudocount=F){
motifMatrix <- sapply(motifs, stringToCharVec)
if(!pseudocount){
profile <- apply(motifMatrix, 1, function(row){
count <- length(row)
freqA <- sum(row=="A")/count
freqC <- sum(row=="C")/count
freqG <- sum(row=="G")/count
freqT <- sum(row=="T")/count
return(c(freqA, freqC, freqG, freqT))
})
}
else{
profile <- apply(motifMatrix, 1, function(row){
count <- length(row) + 4
freqA <- (sum(row=="A")+1)/count
freqC <- (sum(row=="C")+1)/count
freqG <- (sum(row=="G")+1)/count
freqT <- (sum(row=="T")+1)/count
return(c(freqA, freqC, freqG, freqT))
})
}
profile <- t(profile)
colnames(profile) <- c("A","C","G","T")
return(profile)
}
motifsToProfile <- function(motifs, pseudocount=F){
noOfMotifs <- length(motifs)
count <- ifelse(pseudocount, noOfMotifs+4, noOfMotifs)
motifMatrix <- matrix(unlist(strsplit(x=motifs, split="")), ncol=noOfMotifs)
if(!pseudocount){
profile <- apply(motifMatrix, 1, function(row){
freqA <- sum(row=="A")/count
freqC <- sum(row=="C")/count
freqG <- sum(row=="G")/count
freqT <- sum(row=="T")/count
return(c(freqA, freqC, freqG, freqT))
})
}
else{
profile <- apply(motifMatrix, 1, function(row){
freqA <- (sum(row=="A")+1)/count
freqC <- (sum(row=="C")+1)/count
freqG <- (sum(row=="G")+1)/count
freqT <- (sum(row=="T")+1)/count
return(c(freqA, freqC, freqG, freqT))
})
}
profile <- t(profile)
colnames(profile) <- c("A","C","G","T")
return(profile)
}
###############################################
#### Given a set of motifs         ############
#### Calculate the count matrix    ########
###############################################
motifsToCountMatrix <- function(motifs){
noOfMotifs <- length(motifs)
motifMatrix <- matrix(unlist(strsplit(x=motifs, split="")), ncol=noOfMotifs)
countMat <- apply(motifMatrix, 1, function(row){
freqA <- sum(row=="A")
freqC <- sum(row=="C")
freqG <- sum(row=="G")
freqT <- sum(row=="T")
return(c(freqA, freqC, freqG, freqT))
})
countMat <- t(countMat)
colnames(countMat) <- c("A","C","G","T")
return(countMat)
}
countMatrixToProfile <- function(countMatrix, pseudocount=F){
if(pseudocount){
countMatrix <- countMatrix + 1
}
noOfMotifs <- sum(countMatrix[1,])
profile <- countMatrix/noOfMotifs
return(profile)
}
updateCountMatrixForMotifDeletion <- function(countMatrix, motif){
motifCount <- motifsToCountMatrix(motif)
updatedCountMatrix <- countMatrix - motifCount
return(updatedCountMatrix)
}
updateCountMatrixForMotifAddition <- function(countMatrix, motif){
motifCount <- motifsToCountMatrix(motif)
updatedCountMatrix <- countMatrix + motifCount
return(updatedCountMatrix)
}
###############################################
#### Calculate score of motifs  ###############
###############################################
scoreOfMotifs <- function(motifs){
profile <- motifsToProfile(motifs)
noOfMotifs <- length(motifs)
score <- scoreOfMotifsFromProfile(profile, noOfMotifs)
return(score)
}
scoreOfMotifsFromProfile <- function(profile, noOfMotifs){
posScores <- apply(profile, 1, function(row){
frequentColIndex <- which(row==max(row))[1]
onePosScore <- sum(row[-frequentColIndex])
return(onePosScore)
})
score <- sum(posScores) * noOfMotifs
return(score)
}
scoreOfMotifsFromCountMatrix <- function(countMatrix){
posScores <- apply(countMatrix, 1, function(row){
frequentColIndex <- which(row==max(row))[1]
onePosScore <- sum(row[-frequentColIndex])
return(onePosScore)
})
score <- sum(posScores)
return(score)
}
###############################################
#### Find Consensus  motif  ###################
###############################################
consensusMotif <- function(motifs){
profile <- motifsToProfile(motifs)
consensusMotif <- consensusMotifFromProfile(profile)
return(consensusMotif)
}
consensusMotifFromProfile <- function(profile){
cols <- colnames(profile)
colIndexes <- apply(profile, 1, function(row){
return(which(row==max(row))[1])
})
consensusVec <- cols[colIndexes]
consensus <- paste0(consensusVec, collapse="")
return(consensus)
}
###############################################
#### Calculate motifs from profile   ##########
#### motif = Profile-most probable kmer #######
###############################################
profileToMotifs <- function(profile, dnaStrings){
k <- nrow(profile)
motifs <- sapply(dnaStrings, function(dna){
motif <- profileMostProbableKmer(dna=dna, k=k, profile=profile)[1]
return(motif)
})
return(motifs)
}
profileRandomKmer <- function(profile, kmers, dna=NA, k=0){
## if kmers are not gives, then kmers are generated from dna and k
if(is.null(kmers) || is.na(kmers))
kmers <- getKmers(text=dna, k=k, unique=T)
probabilities <- sapply(kmers, probabilityOfDna, profile)
randomKmer <- sample(kmers, size=1, prob=probabilities)
return(randomKmer)
}
#debug(probabilityOfDna)
GreedyMotifSearch <- function(dnaStrings, k, t, pseudocount=F){
bestMotifs <- sapply(dnaStrings, substring, 1, k)
bestMotifsScore <- scoreOfMotifs(bestMotifs)
kmersInString1 <- getKmers(text=dnaStrings[1], k=k, unique=T)
updateBestMotifsFromAnIteration <- function(initialMotif){
curMotifs <- rep("", t)
curMotifs[1] <- initialMotif
tmp <- sapply(2:t, function(i){
profile <- motifsToProfile(motifs=curMotifs[1:(i-1)], pseudocount=pseudocount)
curMotifs[i] <<- profileMostProbableKmer(dna=dnaStrings[i], k=k, profile=profile)[1]
return(NA)
})
curMotifsScore <- scoreOfMotifs(curMotifs)
if(curMotifsScore < bestMotifsScore){
bestMotifs <<- curMotifs
bestMotifsScore <<- curMotifsScore
}
}
#debug(updateBestMotifsFromAnIteration)
sapply(kmersInString1, updateBestMotifsFromAnIteration)
return(bestMotifs)
}
#-------------------------------------------------
setwd("D:/Dropbox/Courses/Coursera Courses/Bioinformatics Algorithms (Part 1)/Bioinformatics-Algorithms/Codes R/My codes for week 3")
#Identifying the evening element
inputFile <- "data/dataset_160_9.txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- GreedyMotifSearch(dnaStrings, k, t, pseudocount=T)
cat(motifs, sep="\n")
inputFile <- "data/dataset_160_9 (1).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- GreedyMotifSearch(dnaStrings, k, t, pseudocount=T)
cat(motifs)
RandomizedMotifSearch <- function(dnaStrings, k, t, iteration=1){
selectRandomKmer <- function(text, k){
kmers <- getKmers(text=text, k=k, unique=T)
randomKmer <- sample(x=kmers, size=1)
return(randomKmer)
}
oneIterationOfRandomizedSearch <- function(){
bestMotifs <- sapply(dnaStrings, selectRandomKmer, k)
bestMotifsScore <- scoreOfMotifs(bestMotifs)
#     count <- 0
while(TRUE){
#       count <- count + 1
#       cat (count)
#       cat(",")
profile <- motifsToProfile(bestMotifs, pseudocount=T)
newMotifs <- profileToMotifs(profile=profile, dnaStrings=dnaStrings)
newMotifsScore <- scoreOfMotifs(newMotifs)
if(newMotifsScore < bestMotifsScore){
bestMotifs <- newMotifs
bestMotifsScore <- newMotifsScore
}
else{
return(list(motifs=bestMotifs, score=bestMotifsScore))
}
}
}
iteratedMotifs <- sapply(1:iteration, function(iter){
if(iter %% 10 == 0)
print(iter)
oneIterationBestMotifs <- oneIterationOfRandomizedSearch()
return(oneIterationBestMotifs)
})
scores <- unlist(iteratedMotifs["score",])
bestIndex <- which(scores==min(scores))[1]
bestMotifs <- iteratedMotifs["motifs",bestIndex]$motifs
return(bestMotifs)
}
#debug(RandomizedMotifSearch)
inputFile <- "data/dataset_161_5.txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
cat(motifs)
library("beepr")
library("audio")
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (1).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
cat(motifs)
library("beepr")
library("audio")
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (2).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
cat(motifs)
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (3).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
if(require(Revobase)){
setMKLthreads(4)
}
library("Revobase", lib.loc="D:/Program Files/RRO/R-3.1.1/library")
if(require(Revobase)){
setMKLthreads(4)
}
inputFile <- "data/dataset_161_5 (4).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
inputFile <- "data/dataset_161_5 (5).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=50)
cat(motifs)
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (6).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=70)
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=50)
cat(motifs)
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (8).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=100)
cat(motifs)
while(1>0){wait(beep(4));wait(beep(6))}
inputFile <- "data/dataset_161_5 (9).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
dnaStrings <- inputs[2:length(inputs)]
motifs <- RandomizedMotifSearch(dnaStrings, k, t, iteration=130)
cat(motifs)
while(1>0){wait(beep(4));wait(beep(6))}
GibbsSampler <- function(dnaStrings, k, t, N, iteration=1){
selectRandomKmer <- function(text, k){
maxStart <- str_length(text) - k + 1
randomKmerStart <- sample(1:maxStart, size=1)
randomKmer <- substr(x=text, start=randomKmerStart, stop=randomKmerStart+k-1)
return(randomKmer)
}
dnaStringsKmers <- lapply(dnaStrings, getKmers, k=k, unique=F)
oneIterationOfGibbsSampler <- function(){
curMotifs <- sapply(dnaStrings, selectRandomKmer, k)
bestMotifs <- curMotifs
bestMotifscountMatrix <- motifsToCountMatrix(bestMotifs)
bestMotifsScore <- scoreOfMotifs(bestMotifs)
curCountMatrix <- bestMotifscountMatrix
coreLoopInGibbsSampler <- function(n){
i <- sample(1:t, size=1)
deletedMotif <- bestMotifs[i]
selectedMotifs <- bestMotifs[-i]
selectedCountMatrix <-  updateCountMatrixForMotifDeletion(countMatrix=bestMotifscountMatrix, motif=deletedMotif)
selectedProfile <- countMatrixToProfile(selectedCountMatrix, pseudocount=T)
curMotifs <- bestMotifs
motif_i <- profileRandomKmer(profile=selectedProfile, kmers=dnaStringsKmers[[i]])
curCountMatrix <- updateCountMatrixForMotifAddition(countMatrix=selectedCountMatrix, motif=motif_i)
curMotifs[i] <- motif_i
curMotifsScore <- scoreOfMotifsFromCountMatrix(countMatrix=curCountMatrix)
if(curMotifsScore < bestMotifsScore){
bestMotifs <<- curMotifs
bestMotifsScore <<- curMotifsScore
bestMotifscountMatrix <<- curCountMatrix
}
return(NA)
}
lapply(1:N, coreLoopInGibbsSampler)
cat(file="out.txt", bestMotifs, bestMotifsScore, "===============", sep="\n", append=T)
return(list(motifs=bestMotifs, score=bestMotifsScore))
}
vars <- ls(envir=globalenv())
cl <- makeCluster(getOption("cl.cores", 4))
clusterEvalQ(cl,{
source("code/utility.motif.R")
})
clusterExport(cl=cl, varlist=vars)
iteratedMotifs <-  parSapply(cl, 1:iteration, function(iter){
oneIterationBestMotifs <- oneIterationOfGibbsSampler()
return(oneIterationBestMotifs)
})
stopCluster(cl)
scores <- unlist(iteratedMotifs["score",])
bestIndex <- which(scores==min(scores))[1]
bestMotifs <- iteratedMotifs["motifs",bestIndex]$motifs
return(bestMotifs)
}
inputFile <- "data/dataset_163_4.txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
N <- as.integer(numbers[3])
dnaStrings <- inputs[2:length(inputs)]
print(Sys.time())
motifs <- GibbsSampler(dnaStrings, k, t, N, iteration=20)
print(Sys.time())
cat(motifs)
library("parallel", lib.loc="D:/Program Files/RRO/R-3.1.1/library")
inputFile <- "data/dataset_163_4 (1).txt"
inputs <- readLines(con=inputFile, warn=F)
numbers <- strsplit(inputs[1], " ")[[1]]
k <- as.integer(numbers[1])
t <- as.integer(numbers[2])
N <- as.integer(numbers[3])
dnaStrings <- inputs[2:length(inputs)]
print(Sys.time())
motifs <- GibbsSampler(dnaStrings, k, t, N, iteration=20)
print(Sys.time())
cat(motifs)
motifs <- GreedyMotifSearch(c("CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC", "GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC", "GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG"), 7, 3, pseudocount=T)
cat(motifs)
log2(.4)*.4+log2(.3)*.3+log2(1)*1+log2(.4)*.4+log2(.5)*.5+log2(1)*1+
0
log2(.4)*.4+log2(.3)*.3+log2(1)*1+log2(.4)*.4+log2(.5)*.5+log2(1)*1
